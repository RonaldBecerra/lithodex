{"ast":null,"code":"import * as auxiliarFunctions from \"./otherFunctions\";\nimport _ from \"lodash\";\nexport function riseLayer(li, layer, i) {\n  var previous = li[i - 1];\n  previous.lowerLimit = _.cloneDeep(layer.lowerLimit);\n  previous.upperLimit[0] = auxiliarFunctions.repairNumber(previous.lowerLimit[0][0] + previous.thickness[0][0], 15);\n  previous.upperLimit[1] = auxiliarFunctions.repairNumber(previous.lowerLimit[1][0] + previous.thickness[1][0], 15);\n  li[i] = previous;\n  layer.lowerLimit = _.cloneDeep(previous.upperLimit);\n  layer.upperLimit[0] = auxiliarFunctions.repairNumber(layer.lowerLimit[0][0] + layer.thickness[0][0], 15);\n  layer.upperLimit[1] = auxiliarFunctions.repairNumber(layer.lowerLimit[1][0] + layer.thickness[1][0], 15);\n  li[i - 1] = layer;\n  return li;\n}\nexport function lowerLayer(li, layer, i) {\n  var previous = li[i + 1];\n  layer.lowerLimit = _.cloneDeep(previous.lowerLimit);\n  layer.upperLimit[0] = auxiliarFunctions.repairNumber(layer.lowerLimit[0][0] + layer.thickness[0][0], 15);\n  layer.upperLimit[1] = auxiliarFunctions.repairNumber(layer.lowerLimit[1][0] + layer.thickness[1][0], 15);\n  li[i + 1] = layer;\n  previous.lowerLimit = _.cloneDeep(layer.upperLimit);\n  previous.upperLimit[0] = auxiliarFunctions.repairNumber(previous.lowerLimit[0][0] + previous.thickness[0][0], 15);\n  previous.upperLimit[1] = auxiliarFunctions.repairNumber(previous.lowerLimit[1][0] + previous.thickness[1][0], 15);\n  li[i] = previous;\n  return li;\n}\n\nfunction binarySearchForLayerList(inferiorBound, superiorBound, layerList, unit, value) {\n  var index = null;\n  var sumBounds = null;\n  var elem = null;\n\n  while (superiorBound >= inferiorBound) {\n    sumBounds = inferiorBound + superiorBound;\n    index = sumBounds % 2 == 0 ? sumBounds / 2 : Math.floor(sumBounds / 2);\n    elem = layerList[index];\n\n    if (value <= elem.upperLimit[unit][0]) {\n      if (elem.lowerLimit[unit][0] <= value) {\n        return index;\n      } else {\n        superiorBound = index - 1;\n      }\n    } else {\n      inferiorBound = index + 1;\n    }\n  }\n\n  return null;\n}\n\nexport function createLayerListForShot(minHeight, maxHeight, layerList, unit, factorThickness) {\n  if (layerList.length == 0) {\n    return [];\n  }\n\n  var array = layerList.reverse();\n  var len_MinusOne = layerList.length - 1;\n  var indexMax = len_MinusOne;\n  var indexMin = 0;\n\n  if (maxHeight < array[0].lowerLimit[unit][0] || minHeight > array[len_MinusOne].upperLimit[unit][0]) {\n    return [];\n  }\n\n  if (maxHeight < array[len_MinusOne].upperLimit[unit][0]) {\n    indexMax = binarySearchForLayerList(0, len_MinusOne, array, unit, maxHeight);\n    array = array.slice(0, indexMax + 1);\n  }\n\n  if (minHeight > array[0].lowerLimit[unit][0]) {\n    indexMin = binarySearchForLayerList(0, indexMax, array, unit, minHeight);\n    array = array.slice(indexMin);\n  }\n\n  var firstElem = array[0];\n  var newLowerLimit = Math.max(minHeight, firstElem.lowerLimit[unit][0]);\n  firstElem.thickness[unit] = auxiliarFunctions.repairNumber(firstElem.upperLimit[unit][0] - newLowerLimit, 20);\n  firstElem.shownHeight[unit] = firstElem.thickness[unit][0] * factorThickness;\n  firstElem.lowerLimit[unit] = auxiliarFunctions.repairNumber(newLowerLimit, 20);\n  array[0] = firstElem;\n  var lenArray_MinusOne = array.length - 1;\n  var lastElem = array[lenArray_MinusOne];\n  var newUpperLimit = Math.min(maxHeight, lastElem.upperLimit[unit][0]);\n  lastElem.thickness[unit] = auxiliarFunctions.repairNumber(newUpperLimit - lastElem.lowerLimit[unit][0], 20);\n  lastElem.shownHeight[unit] = lastElem.thickness[unit][0] * factorThickness;\n  lastElem.upperLimit[unit] = auxiliarFunctions.repairNumber(newUpperLimit, 20);\n  array[lenArray_MinusOne] = lastElem;\n  return array.reverse();\n}\nexport function getStratumsIndexes(minHeight, maxHeight, layerList, unit, factorThickness) {\n  if (layerList.length == 0) {\n    return [null, null];\n  }\n\n  var array = layerList.reverse();\n  var len_MinusOne = layerList.length - 1;\n  var indexMax = len_MinusOne;\n  var indexMin = 0;\n\n  if (maxHeight < array[0].lowerLimit[unit][0] || minHeight > array[len_MinusOne].upperLimit[unit][0]) {\n    return [null, null];\n  }\n\n  if (maxHeight < array[len_MinusOne].upperLimit[unit][0]) {\n    indexMax = binarySearchForLayerList(0, len_MinusOne, array, unit, maxHeight);\n  }\n\n  if (minHeight > array[0].lowerLimit[unit][0]) {\n    indexMin = binarySearchForLayerList(0, indexMax, array, unit, minHeight);\n  }\n\n  return [len_MinusOne - indexMin, len_MinusOne - indexMax];\n}\n\nfunction binarySearchForGammaRayXValues(inferiorBound, superiorBound, array, value, kindOfSearch) {\n  var len = array.length;\n  var index = null;\n  var sumBounds = null;\n  var elem = null;\n\n  while (superiorBound >= inferiorBound) {\n    sumBounds = inferiorBound + superiorBound;\n    index = sumBounds % 2 == 0 ? sumBounds / 2 : Math.floor(sumBounds / 2);\n    elem = array[index];\n\n    if (value == elem) {\n      break;\n    } else if (value < elem) {\n      var indexPrev = index - 1;\n\n      if (kindOfSearch == 0 && array[indexPrev] <= value) {\n        return indexPrev;\n      }\n\n      superiorBound = indexPrev;\n    } else {\n      var indexNext = index + 1;\n\n      if (kindOfSearch == 1 && value <= array[indexNext]) {\n        return indexNext;\n      }\n\n      inferiorBound = indexNext;\n    }\n  }\n\n  return index;\n}\n\nexport function createGammaRayValuesProvisional(minHeight, maxHeight, gammaRayValues, unit) {\n  var array = unit == 0 ? _.cloneDeep(gammaRayValues.xValuesMeters) : _.cloneDeep(gammaRayValues.xValuesFeet);\n  array.reverse();\n  var len_MinusOne = array.length - 1;\n  var lastIndex = len_MinusOne;\n  var firstIndex = 0;\n\n  var minDifference = _.cloneDeep(gammaRayValues.minDifference);\n\n  var empty = {\n    xValuesMeters: [],\n    xValuesFeet: [],\n    yValues: [],\n    numberMeasurements: 0,\n    maxYValue: null,\n    minYValue: null,\n    minDifference: [null, null]\n  };\n\n  if (len_MinusOne < 0 || maxHeight < array[0] || array[len_MinusOne] < minHeight) {\n    return empty;\n  }\n\n  if (maxHeight <= array[len_MinusOne]) {\n    lastIndex = binarySearchForGammaRayXValues(0, lastIndex, array, maxHeight, 0);\n    array = array.slice(0, lastIndex + 1);\n\n    if (array[lastIndex] < minHeight) {\n      return empty;\n    }\n  }\n\n  if (array[0] <= minHeight) {\n    firstIndex = binarySearchForGammaRayXValues(0, lastIndex, array, minHeight, 1);\n    array = array.slice(firstIndex);\n  }\n\n  var lenNewArray = array.length;\n\n  if (lenNewArray > 1) {\n    var difference = null;\n\n    for (i = 1; i < lenNewArray; i++) {\n      difference = array[i] - array[i - 1];\n\n      if (difference < minDifference[unit]) {\n        minDifference[unit] = difference;\n      }\n    }\n  }\n\n  var r_firstIndex = len_MinusOne - lastIndex;\n  var r_lastIndex_PlusOne = len_MinusOne - firstIndex + 1;\n  var yValues = gammaRayValues.yValues.slice(r_firstIndex, r_lastIndex_PlusOne);\n  return {\n    xValuesMeters: gammaRayValues.xValuesMeters.slice(r_firstIndex, r_lastIndex_PlusOne),\n    xValuesFeet: gammaRayValues.xValuesFeet.slice(r_firstIndex, r_lastIndex_PlusOne),\n    yValues: yValues,\n    numberMeasurements: yValues.length,\n    maxYValue: gammaRayValues.maxYValue,\n    minYValue: gammaRayValues.minYValue,\n    minDifference: minDifference\n  };\n}","map":{"version":3,"sources":["C:/Users/Ronald/Documents/Universidad/Miniproyecto/Proyecto final - geología/Versiones de la aplicación/lithodex/src/genericFunctions/plotFunctions.js"],"names":["auxiliarFunctions","_","riseLayer","li","layer","i","previous","lowerLimit","cloneDeep","upperLimit","repairNumber","thickness","lowerLayer","binarySearchForLayerList","inferiorBound","superiorBound","layerList","unit","value","index","sumBounds","elem","Math","floor","createLayerListForShot","minHeight","maxHeight","factorThickness","length","array","reverse","len_MinusOne","indexMax","indexMin","slice","firstElem","newLowerLimit","max","shownHeight","lenArray_MinusOne","lastElem","newUpperLimit","min","getStratumsIndexes","binarySearchForGammaRayXValues","kindOfSearch","len","indexPrev","indexNext","createGammaRayValuesProvisional","gammaRayValues","xValuesMeters","xValuesFeet","lastIndex","firstIndex","minDifference","empty","yValues","numberMeasurements","maxYValue","minYValue","lenNewArray","difference","r_firstIndex","r_lastIndex_PlusOne"],"mappings":"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","sourcesContent":["import * as auxiliarFunctions from './otherFunctions'\r\nimport _ from \"lodash\"\r\n\r\n// Sirve para subir  estrato de lugar una posición\r\nexport function riseLayer(li,layer,i){\r\n\tconst previous = li[i-1]; // El estrato que estaba en la posición en la que ahora estará el actual\r\n\r\n\tprevious.lowerLimit    = _.cloneDeep(layer.lowerLimit);\r\n\tprevious.upperLimit[0] = auxiliarFunctions.repairNumber(previous.lowerLimit[0][0] + previous.thickness[0][0], 15);\r\n\tprevious.upperLimit[1] = auxiliarFunctions.repairNumber(previous.lowerLimit[1][0] + previous.thickness[1][0], 15);\r\n\tli[i] = previous;\r\n\r\n\tlayer.lowerLimit    = _.cloneDeep(previous.upperLimit);\r\n\tlayer.upperLimit[0] = auxiliarFunctions.repairNumber(layer.lowerLimit[0][0] + layer.thickness[0][0], 15);\r\n\tlayer.upperLimit[1] = auxiliarFunctions.repairNumber(layer.lowerLimit[1][0] + layer.thickness[1][0], 15);\r\n\tli[i-1]             = layer;\r\n\r\n\treturn li;\r\n}\r\n\r\n// Sirve para bajar al estrato de lugar una posición\r\nexport function lowerLayer(li,layer,i){\r\n\tconst previous = li[i+1]; // El estrato que estaba en la posición en la que ahora estará el actual\r\n\r\n\tlayer.lowerLimit    = _.cloneDeep(previous.lowerLimit);\r\n\tlayer.upperLimit[0] = auxiliarFunctions.repairNumber(layer.lowerLimit[0][0] + layer.thickness[0][0], 15);\r\n\tlayer.upperLimit[1] = auxiliarFunctions.repairNumber(layer.lowerLimit[1][0] + layer.thickness[1][0], 15);\r\n\tli[i+1]             = layer;\r\n\r\n\tprevious.lowerLimit    = _.cloneDeep(layer.upperLimit);\r\n\tprevious.upperLimit[0] = auxiliarFunctions.repairNumber(previous.lowerLimit[0][0] + previous.thickness[0][0], 15);\r\n\tprevious.upperLimit[1] = auxiliarFunctions.repairNumber(previous.lowerLimit[1][0] + previous.thickness[1][0], 15);\t\t\r\n\tli[i]                  = previous;\r\n\r\n\treturn li;\r\n}\r\n\r\n/* Para buscar de modo binario el índice de un estrato particular de una lista de estratos, \r\n   tal que un valor que recibe la función está comprendido entre los límites del estrato\r\n */\r\nfunction binarySearchForLayerList(inferiorBound, superiorBound, layerList, unit, value){\r\n\tvar index     = null; // Índice que retorna esta función\r\n\tvar sumBounds = null; // Suma de la cota superior con la inferior\r\n\tvar elem      = null; // Elemento de la lista de estratos que se está examinando en un momento dado\r\n\r\n\twhile (superiorBound >= inferiorBound){\r\n\t\tsumBounds = inferiorBound + superiorBound;\r\n\t\tindex     = (sumBounds%2 == 0) ? (sumBounds/2) : Math.floor(sumBounds/2);\r\n\t\telem      = layerList[index];\r\n\r\n\t\tif (value <= elem.upperLimit[unit][0]){\r\n\t\t\tif (elem.lowerLimit[unit][0] <= value){\r\n\t\t\t\treturn index; // Caso en que encontramos el elemento, porque las dos condiciones fueron satisfechas\r\n\t\t\t} else{\r\n\t\t\t\tsuperiorBound = index - 1;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tinferiorBound = index + 1;\r\n\t\t}\r\n\t}\r\n\t// En principio nunca deberíamos caer en este caso, porque la búsqueda binaria sólo debería hacerse cuando el valor está comprendido\r\n\t// entre los límites. Pero lo dejamos para que dé errores si esa condición no se cumplre\r\n\treturn null; \r\n}\r\n\r\n/* Para construir el arreglo de estratos provisional para hacer una captura de vista. Tómese en cuenta que no modifica\r\n   en los estratos los valores correspondientes a la unidad que no se va a mostrar en la captura. Por ejemplo, si \r\n   estamos trabajando en metros no se modifican los límites expresados en pies.\r\n */\r\nexport function createLayerListForShot(minHeight, maxHeight, layerList, unit, factorThickness){\r\n\tif (layerList.length == 0){\r\n\t\treturn [];\r\n\t}\r\n\r\n\t// Recuerda que los estratos están ordenados de forma decreciente. Revertimos el arreglo por comodidad\r\n\tvar array        = layerList.reverse(); \r\n\tvar len_MinusOne = layerList.length - 1;\r\n\tvar indexMax     = len_MinusOne; // Índice del estrato superior que saldrá en la captura\r\n\tvar indexMin     = 0;            // Índice del estrato inferior que saldrá en la captura\r\n\r\n\t// Caso en que devolvemos un arreglo vacío porque los límites indican que ningún estrato está incluido entre ellos\r\n\t// Como está actualmente la aplicación, en los afloramientos esto no debería ocurrir nunca, pero sí podría pasar en los núcleos,\r\n\t// porque puede que capturemos una parte que sólo tiene registrado valores gamma-ray\r\n\tif ((maxHeight < array[0].lowerLimit[unit][0]) || (minHeight > array[len_MinusOne].upperLimit[unit][0])){\r\n\t\treturn [];\r\n\t}\r\n\r\n\t// Actualizamos el índice superior sólo si es necesario\r\n\tif (maxHeight < array[len_MinusOne].upperLimit[unit][0]){\r\n\t\tindexMax = binarySearchForLayerList(0, len_MinusOne, array, unit, maxHeight);\r\n\t\tarray    = array.slice(0,indexMax+1);\r\n\t}\r\n\r\n\t// Actualizamos el índice inferior sólo si es necesario\r\n\tif (minHeight > array[0].lowerLimit[unit][0]){\r\n\t\tindexMin = binarySearchForLayerList(0, indexMax, array, unit, minHeight);\r\n\t\tarray    = array.slice(indexMin);\r\n\t}\r\n\r\n\t// Modificamos el estrato inferior de la captura\r\n\tlet firstElem     = array[0];\r\n\tlet newLowerLimit = Math.max(minHeight, firstElem.lowerLimit[unit][0]);\r\n\r\n\tfirstElem.thickness[unit]   = auxiliarFunctions.repairNumber(firstElem.upperLimit[unit][0] - newLowerLimit, 20);\r\n\tfirstElem.shownHeight[unit] = firstElem.thickness[unit][0] * factorThickness;\r\n\tfirstElem.lowerLimit[unit]  = auxiliarFunctions.repairNumber(newLowerLimit,20);\r\n\tarray[0] = firstElem;\r\n\r\n\t// Modificamos el estrato superior de la captura\r\n\tlet lenArray_MinusOne = array.length -1;\r\n\r\n\tlet lastElem      = array[lenArray_MinusOne];\r\n\tlet newUpperLimit = Math.min(maxHeight,lastElem.upperLimit[unit][0]);\r\n\r\n\tlastElem.thickness[unit]   = auxiliarFunctions.repairNumber(newUpperLimit - lastElem.lowerLimit[unit][0], 20);\r\n\tlastElem.shownHeight[unit] = lastElem.thickness[unit][0] * factorThickness;\r\n\tlastElem.upperLimit[unit]  = auxiliarFunctions.repairNumber(newUpperLimit, 20);\r\n\tarray[lenArray_MinusOne]   = lastElem;\r\n\r\n\treturn array.reverse();\r\n}\r\n\r\n/* Esto sirve para que sólo se muestre una parte del total de arreglo de estratos. Devuelve el índice del estrato inferior\r\n   que se mostrará, y el del superior, según las alturas mínima y máxima indicadas. Si el estrato inferior comienza por debajo\r\n   de la altura mínima, o el superior termina por encima de la altura máxima, ninguno de ellos se cortará, sino que permanecerán\r\n   completos.\r\n */\r\nexport function getStratumsIndexes(minHeight, maxHeight, layerList, unit, factorThickness){\r\n\tif (layerList.length == 0){\r\n\t\treturn [null,null];\r\n\t}\r\n\r\n\t// Recuerda que los estratos están ordenados de forma decreciente. Revertimos el arreglo por comodidad\r\n\tvar array        = layerList.reverse(); \r\n\tvar len_MinusOne = layerList.length - 1;\r\n\tvar indexMax     = len_MinusOne; // Índice del estrato superior del arreglo\r\n\tvar indexMin     = 0;            // Índice del estrato inferior del arreglo\r\n\r\n\t// Caso en que devolvemos índices nulos porque los límites indican que ningún estrato está incluido entre ellos\r\n\t// Como está actualmente la aplicación, en los afloramientos esto no debería ocurrir nunca, pero sí podría pasar en los núcleos,\r\n\t// porque puede que capturemos una parte que sólo tiene registrado valores gamma-ray\r\n\tif ((maxHeight < array[0].lowerLimit[unit][0]) || (minHeight > array[len_MinusOne].upperLimit[unit][0])){\r\n\t\treturn [null, null];\r\n\t}\r\n\r\n\t// Actualizamos el índice superior sólo si es necesario\r\n\tif (maxHeight < array[len_MinusOne].upperLimit[unit][0]){\r\n\t\tindexMax = binarySearchForLayerList(0, len_MinusOne, array, unit, maxHeight);\r\n\t}\r\n\r\n\t// Actualizamos el índice inferior sólo si es necesario\r\n\tif (minHeight > array[0].lowerLimit[unit][0]){\r\n\t\tindexMin = binarySearchForLayerList(0, indexMax, array, unit, minHeight);\r\n\t}\r\n\r\n\t// El primer elemento es el índice inferior del arreglo, y el segundo es el superior\r\n\t// Recuérdese que el arreglo original está invertido\r\n\treturn [len_MinusOne-indexMin, len_MinusOne-indexMax];\r\n}\r\n\r\n/* Función para buscar de modo binario un índice en un arreglo de valores de eje x de gamma-ray, es decir, valores de profundidad.\r\n   Puede ser el índice del máximo elemento menor o igual, o bien del mínimo elemento mayor o igual al valor \"value\" dado.\r\n   Cuál de los dos tipos de búsqueda haremos depende del parámetro \"kindOfSearch\". Si éste es 0, buscamos un elemento menor o igual,\r\n   y si es 1, buscamos un elemento mayor o igual.\r\n */\r\nfunction binarySearchForGammaRayXValues(inferiorBound, superiorBound, array, value, kindOfSearch){\r\n\tconst len = array.length; // Cantidad de elementos en el arreglo\r\n\r\n\tvar index     = null; // Índice que retorna esta función\r\n\tvar sumBounds = null; // Suma de la cota superior con la inferior\r\n\tvar elem      = null; // Elemento que se está examinando actualmente\r\n\r\n\twhile (superiorBound >= inferiorBound){\r\n\t\tsumBounds = inferiorBound + superiorBound;\r\n\t\tindex     = (sumBounds%2 == 0) ? (sumBounds/2) : Math.floor(sumBounds/2);\r\n\t\telem      = array[index];\r\n\r\n\t\tif (value == elem){\r\n\t\t\tbreak; // El elemento coincide con el valor que estábamos buscando\r\n\t\t}\r\n\t\telse if (value < elem){\r\n\t\t\tconst indexPrev = index - 1;\r\n\r\n\t\t\t// Si estamos haciendo una búsqueda de menor o igual, hay que revisar el elemento anterior\t\t\t\t\t\t\r\n\t\t\tif ((kindOfSearch == 0) && (array[indexPrev] <= value)){\r\n\t\t\t\treturn indexPrev;\r\n\t\t\t} \r\n\t\t\tsuperiorBound = indexPrev;\r\n\t\t}\r\n\t\telse { // Caso en que elem < value\r\n\t\t\tconst indexNext = index + 1;\r\n\r\n\t\t\t// Si estamos haciendo una búsqueda de mayor o igual, debemos revisar el elemento siguiente\r\n\t\t\tif ((kindOfSearch == 1) && (value <= array[indexNext])){\r\n\t\t\t\treturn indexNext;\r\n\t\t\t}\r\n\t\t\tinferiorBound = indexNext;\r\n\t\t}\r\n\t}\r\n\treturn index;\r\n}\r\n\r\n// Para construir el objeto con los valores de gamma-ray para hacer una captura de la vista, o bien paara tomar sólo un extracto\r\nexport function createGammaRayValuesProvisional(minHeight, maxHeight, gammaRayValues, unit){\r\n\t// Es necesario copiar el arreglo correspondiente, no referenciarlo, porque entonces no estaremos refiriendo\r\n\t// al mismo objeto\r\n\tvar array = (unit == 0) ? _.cloneDeep(gammaRayValues.xValuesMeters) : _.cloneDeep(gammaRayValues.xValuesFeet);\r\n\t\r\n\t// Los valores están ordenados de forma decreciente, así que invertimos el arreglo por comodidad\r\n\tarray.reverse(); \r\n\r\n\tconst len_MinusOne  = array.length - 1;  // Cantidad de elementos en el arreglo, menos una unidad\r\n\tvar   lastIndex     = len_MinusOne;      // Último índice que se tomará del arreglo\r\n\tvar   firstIndex    = 0;                 // Primer índice que se tomará del arreglo\r\n\tvar   minDifference = _.cloneDeep(gammaRayValues.minDifference); // Mínima diferencia entre una medición y otra\r\n\r\n\t// Objeto con los campos vacíos\r\n\tconst empty = {\r\n\t\txValuesMeters: [],\r\n\t\txValuesFeet:   [],\r\n\t\tyValues:       [],\r\n\r\n\t\tnumberMeasurements: 0,\r\n\t\tmaxYValue:          null,\r\n\t\tminYValue:          null,\r\n\t\tminDifference:      [null,null],\r\n\t}\r\n\r\n\t/* Casos en que no hay elementos que mostrar: \r\n\t   \t1) No hay elementos en el arreglo,\r\n\t   \t2) altura máxima menor que el mínimo elemento del arreglo,\r\n\t    3) o altura mínima mayor que el máximo elemento del arreglo, \r\n\t */\r\n\tif ((len_MinusOne < 0) || (maxHeight < array[0]) || (array[len_MinusOne] < minHeight) ){\r\n\t\treturn empty;\r\n\t}\r\n\r\n\t// Reducimos el arreglo según la altura máxima a mostrar, pero sólo si la altura máxima no es mayor que todos\r\n\t// los elementos del arreglo, porque en ese caso habrá que devolverlos todos\r\n\tif (maxHeight <= array[len_MinusOne]) {\r\n\t\tlastIndex = binarySearchForGammaRayXValues(0, lastIndex, array, maxHeight, 0);\r\n\t\tarray     = array.slice(0,lastIndex+1);\r\n\r\n\t\t// El haber reducido el arreglo puede haber hecho que la altura mínima sea mayor que el máximo del sobrante del arreglo\r\n\t\tif (array[lastIndex] < minHeight){\r\n\t\t\treturn empty;\r\n\t\t}\r\n\t}\r\n\r\n\t// Reducimos el arreglo según la altura mínima a mostrar, pero sólo si la altura mínima no es menor que todos\r\n\t// los elementos del arreglo, porque en ese caso habrá que devolverlos todos\r\n\tif (array[0] <= minHeight) {\r\n\t\tfirstIndex = binarySearchForGammaRayXValues(0, lastIndex, array, minHeight, 1);\r\n\t\tarray      = array.slice(firstIndex);\r\n\t}\r\n\r\n\t// Actualizamos la mínima diferencia entre una medición y otra.\r\n\tconst lenNewArray = array.length; // Cantidad de elementos en el arreglo sobrante\r\n\tif (lenNewArray > 1){\r\n\t\tvar difference = null;\r\n\t\tfor (i = 1; i < lenNewArray; i++){\r\n\t\t\tdifference = array[i] - array[i-1];\r\n\t\t\tif (difference < minDifference[unit]){\r\n\t\t\t\tminDifference[unit] = difference;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Índices con los que cortaremos los arreglos del objeto a retornar\r\n\tconst r_firstIndex        = len_MinusOne - lastIndex;\r\n\tconst r_lastIndex_PlusOne = len_MinusOne - firstIndex + 1;\r\n\r\n\tlet yValues = gammaRayValues.yValues.slice(r_firstIndex, r_lastIndex_PlusOne);\r\n\r\n\treturn({\r\n\t\txValuesMeters: gammaRayValues.xValuesMeters.slice(r_firstIndex, r_lastIndex_PlusOne),\r\n\t\txValuesFeet:   gammaRayValues.xValuesFeet.slice(r_firstIndex, r_lastIndex_PlusOne),\r\n\t\tyValues,\r\n\r\n\t\tnumberMeasurements: yValues.length,\r\n\t\t// Siempre es necesario conservar los valores mayor y menor valor de gamma-ray originales\r\n\t\tmaxYValue: gammaRayValues.maxYValue,\r\n\t\tminYValue: gammaRayValues.minYValue,\r\n\t\tminDifference,\r\n\t})\r\n}"]},"metadata":{},"sourceType":"module"}