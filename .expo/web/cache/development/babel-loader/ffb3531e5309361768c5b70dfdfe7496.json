{"ast":null,"code":"import * as Regex from \"../constants/regularExpressions\";\nimport * as auxiliarFunctions from \"./otherFunctions\";\nexport function readCoreFile(file) {\n  var DF = [];\n  var GL = [];\n  var BaseHeight = [];\n  var EndHeight = [];\n  var Scale = [];\n  var gammaRayValues = {\n    xValuesMeters: [],\n    xValuesFeet: [],\n    yValues: [],\n    numberMeasurements: 0,\n    maxYValue: null,\n    minYValue: null,\n    minDifference: null\n  };\n  var nullValue = \"?\";\n  var step = null;\n  var lines = file.split(\"\\n\");\n  var linesWithoutSpaces = [];\n\n  for (var i = 0; i < lines.length; i++) {\n    var newLine = lines[i].split(Regex.REGULAR_EXPRESSION_5);\n    linesWithoutSpaces.push(newLine);\n  }\n\n  var lookForDF = true;\n  var lookForGL = true;\n  var lookForBaseHeight = true;\n  var lookForEndHeight = true;\n  var lookForStep = true;\n  var lookForNullValue = true;\n  var condition = true;\n  var headerIndex = null;\n  var feetAreApplied = false;\n  var metersAreApplied = false;\n\n  for (var i = 0; i < linesWithoutSpaces.length; i++) {\n    var currentLine = linesWithoutSpaces[i];\n    var firstElement = currentLine[0];\n\n    if (condition) {\n      var separatedfirstElement = firstElement.split(\".\");\n\n      switch (separatedfirstElement[0]) {\n        case \"EDF\":\n          var value = parseFloat(currentLine[1]);\n          DF.push(value.toString());\n          lookForDF = false;\n          condition = lookForGL || lookForBaseHeight || lookForEndHeight || lookForNullValue || lookForStep;\n\n          if (separatedfirstElement[1] === \"FT\") {\n            DF.push(1);\n            feetAreApplied = true;\n          } else {\n            DF.push(0);\n            metersAreApplied = true;\n          }\n\n          break;\n\n        case \"EGL\":\n          var value = parseFloat(currentLine[1]);\n          GL.push(value.toString());\n          lookForGL = false;\n          condition = lookForDF || lookForBaseHeight || lookForEndHeight || lookForNullValue || lookForStep;\n\n          if (separatedfirstElement[1] === \"FT\") {\n            GL.push(1);\n            feetAreApplied = true;\n          } else {\n            GL.push(0);\n            metersAreApplied = true;\n          }\n\n          break;\n\n        case \"STRT\":\n          var value = parseFloat(currentLine[1]);\n\n          if (currentLine.length > 2) {\n            if (currentLine[3] === \"DEPTH\") {\n              value *= -1;\n            }\n          }\n\n          BaseHeight.push(value.toString());\n          lookForBaseHeight = false;\n          condition = lookForDF || lookForGL || lookForEndHeight || lookForNullValue || lookForStep;\n\n          if (separatedfirstElement[1] === \"FT\") {\n            BaseHeight.push(1);\n            feetAreApplied = true;\n          } else {\n            BaseHeight.push(0);\n            metersAreApplied = true;\n          }\n\n          break;\n\n        case \"STOP\":\n          var value = parseFloat(currentLine[1]);\n\n          if (currentLine.length > 2) {\n            if (currentLine[3] === \"DEPTH\") {\n              value *= -1;\n            }\n          }\n\n          EndHeight.push(value.toString());\n          lookForEndHeight = false;\n          condition = lookForDF || lookForGL || lookForBaseHeight || lookForNullValue || lookForStep;\n\n          if (separatedfirstElement[1] === \"FT\") {\n            EndHeight.push(1);\n            feetAreApplied = true;\n          } else {\n            EndHeight.push(0);\n            metersAreApplied = true;\n          }\n\n          break;\n\n        case \"NULL\":\n          nullValue = parseFloat(currentLine[1]);\n          lookForNullValue = false;\n          condition = lookForDF || lookForGL || lookForBaseHeight || lookForEndHeight || lookForStep;\n          break;\n\n        case \"STEP\":\n          var value = parseFloat(currentLine[1]);\n          lookForStep = false;\n          condition = lookForDF || lookForGL || lookForBaseHeight || lookForEndHeight || lookForNullValue;\n\n          if (separatedfirstElement[1] === \"FT\") {\n            gammaRayValues.minDifference = [auxiliarFunctions.feetToMeters(value)[0], value];\n            Scale = [auxiliarFunctions.repairNumber(value, 20), 1];\n          } else {\n            gammaRayValues.minDifference = [value, auxiliarFunctions.metersToFeet(value)[0]];\n            Scale = [auxiliarFunctions.repairNumber(value, 20), 0];\n          }\n\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    if (firstElement === \"~A\") {\n      headerIndex = i;\n      break;\n    }\n  }\n\n  if (headerIndex != null) {\n    var currentLine = linesWithoutSpaces[headerIndex];\n    var gammaRayPosition = currentLine.findIndex(function (element) {\n      return element === \"GR\";\n    });\n\n    if (feetAreApplied && !metersAreApplied || feetAreApplied && metersAreApplied || !feetAreApplied && !metersAreApplied) {\n      var unit = 1;\n    } else {\n      var unit = 0;\n    }\n\n    var depthPosition = currentLine.findIndex(function (element) {\n      return element === \"Depth\";\n    });\n    var newDepthValueMeters = null;\n    var newDepthValueFeet = null;\n    var newGRValue = null;\n\n    if (gammaRayValues.minDifference != null) {\n      if (unit == 0) {\n        for (i = headerIndex + 1; i < linesWithoutSpaces.length; i++) {\n          currentLine = linesWithoutSpaces[i];\n          newDepthValueMeters = parseFloat(currentLine[depthPosition]) * -1;\n          newDepthValueFeet = auxiliarFunctions.metersToFeet(newDepthValueMeters)[0];\n          newGRValue = parseFloat(currentLine[gammaRayPosition]);\n\n          if (!Number.isNaN(newGRValue)) {\n            gammaRayValues.xValuesMeters.push(newDepthValueMeters);\n            gammaRayValues.xValuesFeet.push(newDepthValueFeet);\n\n            if (newGRValue != nullValue) {\n              gammaRayValues.yValues.push(newGRValue);\n            } else {\n              gammaRayValues.yValues.push(null);\n            }\n          }\n        }\n      } else {\n        for (i = headerIndex + 1; i < linesWithoutSpaces.length; i++) {\n          currentLine = linesWithoutSpaces[i];\n          newDepthValueFeet = parseFloat(currentLine[depthPosition]) * -1;\n          newDepthValueMeters = auxiliarFunctions.feetToMeters(newDepthValueFeet)[0];\n          newGRValue = parseFloat(currentLine[gammaRayPosition]);\n\n          if (!Number.isNaN(newGRValue)) {\n            gammaRayValues.xValuesMeters.push(newDepthValueMeters);\n            gammaRayValues.xValuesFeet.push(newDepthValueFeet);\n\n            if (newGRValue != nullValue) {\n              gammaRayValues.yValues.push(newGRValue);\n            } else {\n              gammaRayValues.yValues.push(null);\n            }\n          }\n        }\n      }\n    } else {\n      var minDifference = 10000000;\n\n      if (unit == 0) {\n        currentLine = linesWithoutSpaces[headerIndex + 1];\n        newDepthValueMeters = parseFloat(currentLine[depthPosition]) * -1;\n        newDepthValueFeet = auxiliarFunctions.metersToFeet(newDepthValueMeters)[0];\n        newGRValue = parseFloat(currentLine[gammaRayPosition]);\n\n        if (!Number.isNaN(newGRValue)) {\n          gammaRayValues.xValuesMeters.push(newDepthValueMeters);\n          gammaRayValues.xValuesFeet.push(newDepthValueFeet);\n\n          if (newGRValue != nullValue) {\n            gammaRayValues.yValues.push(newGRValue);\n          } else {\n            gammaRayValues.yValues.push(null);\n          }\n        }\n\n        var previousLecture = newDepthValueMeters;\n\n        for (i = headerIndex + 2; i < linesWithoutSpaces.length; i++) {\n          currentLine = linesWithoutSpaces[i];\n          newDepthValueMeters = parseFloat(currentLine[depthPosition]) * -1;\n          newDepthValueFeet = auxiliarFunctions.metersToFeet(newDepthValueMeters)[0];\n          newGRValue = parseFloat(currentLine[gammaRayPosition]);\n\n          if (!Number.isNaN(newGRValue)) {\n            gammaRayValues.xValuesMeters.push(newDepthValueMeters);\n            gammaRayValues.xValuesFeet.push(newDepthValueFeet);\n\n            if (newGRValue != nullValue) {\n              gammaRayValues.yValues.push(newGRValue);\n            } else {\n              gammaRayValues.yValues.push(null);\n            }\n\n            minDifference = Math.min(minDifference, previousLecture - newDepthValueMeters);\n            previousLecture = newDepthValueMeters;\n          }\n        }\n\n        gammaRayValues.minDifference = [minDifference, auxiliarFunctions.metersToFeet(minDifference)[0]];\n      } else {\n        currentLine = linesWithoutSpaces[headerIndex + 1];\n        newDepthValueFeet = parseFloat(currentLine[depthPosition]) * -1;\n        newDepthValueMeters = auxiliarFunctions.feetToMeters(newDepthValueFeet)[0];\n        newGRValue = parseFloat(currentLine[gammaRayPosition]);\n\n        if (!Number.isNaN(newGRValue)) {\n          gammaRayValues.xValuesMeters.push(newDepthValueMeters);\n          gammaRayValues.xValuesFeet.push(newDepthValueFeet);\n\n          if (newGRValue != nullValue) {\n            gammaRayValues.yValues.push(newGRValue);\n          } else {\n            gammaRayValues.yValues.push(null);\n          }\n        }\n\n        var previousLecture = newDepthValueFeet;\n\n        for (i = headerIndex + 2; i < linesWithoutSpaces.length; i++) {\n          currentLine = linesWithoutSpaces[i];\n          newDepthValueFeet = parseFloat(currentLine[depthPosition]) * -1;\n          newDepthValueMeters = auxiliarFunctions.feetToMeters(newDepthValueFeet)[0];\n          newGRValue = parseFloat(currentLine[gammaRayPosition]);\n\n          if (!Number.isNaN(newGRValue)) {\n            gammaRayValues.xValuesMeters.push(newDepthValueMeters);\n            gammaRayValues.xValuesFeet.push(newDepthValueFeet);\n\n            if (newGRValue != nullValue) {\n              gammaRayValues.yValues.push(newGRValue);\n            } else {\n              gammaRayValues.yValues.push(null);\n            }\n\n            minDifference = Math.min(minDifference, previousLecture - newDepthValueFeet);\n            previousLecture = newDepthValueFeet;\n          }\n        }\n\n        gammaRayValues.minDifference = [auxiliarFunctions.feetToMeters(minDifference)[0], minDifference];\n      }\n    }\n\n    gammaRayValues.numberMeasurements = gammaRayValues.yValues.length;\n    gammaRayValues.minYValue = Math.min.apply(Math, gammaRayValues.yValues);\n    gammaRayValues.maxYValue = Math.max.apply(Math, gammaRayValues.yValues);\n  }\n\n  return {\n    DF: DF,\n    GL: GL,\n    BaseHeight: BaseHeight,\n    EndHeight: EndHeight,\n    Scale: Scale,\n    gammaRayValues: gammaRayValues\n  };\n}","map":{"version":3,"sources":["C:/Users/Ronald/Documents/Universidad/Miniproyecto/Proyecto final - geología/Versiones de la aplicación/lithodex/src/genericFunctions/readFileFunctions.js"],"names":["Regex","auxiliarFunctions","readCoreFile","file","DF","GL","BaseHeight","EndHeight","Scale","gammaRayValues","xValuesMeters","xValuesFeet","yValues","numberMeasurements","maxYValue","minYValue","minDifference","nullValue","step","lines","split","linesWithoutSpaces","i","length","newLine","REGULAR_EXPRESSION_5","push","lookForDF","lookForGL","lookForBaseHeight","lookForEndHeight","lookForStep","lookForNullValue","condition","headerIndex","feetAreApplied","metersAreApplied","currentLine","firstElement","separatedfirstElement","value","parseFloat","toString","feetToMeters","repairNumber","metersToFeet","gammaRayPosition","findIndex","element","unit","depthPosition","newDepthValueMeters","newDepthValueFeet","newGRValue","Number","isNaN","previousLecture","Math","min","apply","max"],"mappings":"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","sourcesContent":["import * as Regex from '../constants/regularExpressions'\r\nimport * as auxiliarFunctions from './otherFunctions'\r\n\r\n/* Esta función sirve está diseñada para leer archivos con información de núcleos que tengan el mismo formato que los enviados por el profesor José Baena, \r\n   aunque también contempla algunas ligeras variaciones, como si por ejemplo faltan algunos datos.\r\n\r\n   Ésta función asume que los valores de profundidad van apareciendo de forma decreciente; si llegaran a estar desordenados, ocurrirían inconsistencias\r\n */\r\nexport function readCoreFile(file){\r\n\t// En los siguientes arreglos, el primer elemento será el valor, y el segundo será la unidad (0 para metros, y 1 para pies). \r\n\tvar DF         = []; // Drill Floor\r\n\tvar GL         = []; // Ground Level\r\n\tvar BaseHeight = []; // Altura base (la más alta desde la que se comienza a registrar el núcleo)\r\n\tvar EndHeight  = []; // Altura terminal (la más baja a la que se registra el núcleo)\r\n\tvar Scale      = []; // Escala a la que se mostrará el núcleo\r\n\r\n\t// Es necesario separar tanto la lista de valores del eje x, como la lista de valores del eje y, así como también la lista de pares ordenados,\r\n\t// porque de esa forma los leerá la librería usada.\r\n\tvar gammaRayValues = {\r\n\t\txValuesMeters: [], // Conjunto de valores del eje x (profundidades) expresados en metros\r\n\t\txValuesFeet:   [], // Conjunto de valores del eje x (profundidades) expresados en pies\r\n\t\tyValues:       [], // Conjunto de valores del eje y (rayos-gamma) \r\n\r\n\t\tnumberMeasurements: 0,    // Longitud de cada uno de los tres arreglos anteriores \r\n\t\tmaxYValue:          null, // Mayor valor de gamma-ray que se leyó\r\n\t\tminYValue:          null, // Menor valor de gamma-ray que se leyó\r\n\t\tminDifference:      null, // Mínima diferencia de espacio entre una lectura y otra\r\n\t};  \r\n\r\n\tvar nullValue = \"?\"; // Valor que se tomará como nulo al leer la tabla\r\n\tvar step      = null; // Paso (diferencia de altura constante entre una línea de medición y otra)\r\n\tvar lines = file.split(\"\\n\"); // Arreglo cuyos elementos son las líneas del archivo leído\r\n\tvar linesWithoutSpaces = []   /* Arreglo cuyos elementos serán a su vez arreglos. Cada uno de los subarreglos corresponderá a una línea del archivo leído,\r\n\t                                 pero eliminando los espacios entre las palabras, y esa eliminación da lugar a varios elementos (cada palabra). */\r\n\r\n\tfor (var i = 0; i < lines.length; i++){\r\n\t\tvar newLine = lines[i].split(Regex.REGULAR_EXPRESSION_5); // El REGULAR_EXPRESSION_5 es para que la expresión regular del \"split\" reconozca varios espacios seguidos\r\n\t\tlinesWithoutSpaces.push(newLine);\r\n\t}\r\n\r\n\t// Las siguientes variables determinan si todavía hay que buscar el valor correspondiente\r\n\tvar lookForDF          = true; // Drill Floor\r\n\tvar lookForGL          = true; // Ground Level\r\n\tvar lookForBaseHeight  = true; // Altura base\r\n\tvar lookForEndHeight   = true; // Altura terminal (la más profunda)\r\n\tvar lookForStep        = true; // Paso (diferencia de altura constante entre una línea de medición de profundidad y otra)\r\n\tvar lookForNullValue   = true; // Valor que indica nulo en la tabla de valores\r\n\r\n\tvar condition          = true; // Determina si todavía hay que buscar alguno de los elementos cuyo nombre incluye también la unidad de medición, separada por un punto\r\n\tvar headerIndex        = null; // Posición desde la que tiene que leerse la tabla de valores\r\n\r\n\tvar feetAreApplied     = false; // Determina si alguna vez en el documento son utilizados los pies como unidades\r\n\tvar metersAreApplied   = false; // Determina si alguna vez en el documento son utilizados los metros como unidades\r\n\t\r\n\tfor (var i = 0; i < linesWithoutSpaces.length; i++){\r\n\t\tvar currentLine  = linesWithoutSpaces[i];\r\n\t\tvar firstElement = currentLine[0];\r\n\r\n\t\tif (condition){\r\n\t\t\tvar separatedfirstElement = firstElement.split(\".\"); // Esto para que separe por exactamente un punto\r\n\r\n\t\t\tswitch(separatedfirstElement[0]){\r\n\r\n\t\t\t\t// Caso en que buscamos el Drill Floor\r\n\t\t\t\tcase \"EDF\":\r\n\t\t\t\t\tvar value = parseFloat(currentLine[1]); // El 'parseFloat' elimina caracteres adicionales al número, como si por ejemplo tenemos \"3175:\", lo deja en 3175.\r\n\t\t\t\t\tDF.push(value.toString());          // Lo que guardamos es el valor pero en cadena de caracteres, porque así es como será leído después.\r\n\t\t\t\t\tlookForDF = false;\r\n\t\t\t\t\tcondition = (lookForGL || lookForBaseHeight || lookForEndHeight || lookForNullValue || lookForStep );\r\n\t\t\t\t\tif (separatedfirstElement[1] === \"FT\"){\r\n\t\t\t\t\t\tDF.push(1);\r\n\t\t\t\t\t\tfeetAreApplied = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tDF.push(0);\r\n\t\t\t\t\t\tmetersAreApplied = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\r\n\t\t\t\t// Caso en que buscamos el Ground Level\r\n\t\t\t\tcase \"EGL\": \r\n\t\t\t\t\tvar value = parseFloat(currentLine[1]); // El 'parseFloat' elimina caracteres adicionales al número, como si por ejemplo tenemos \"3175:\", lo deja en 3175.\r\n\t\t\t\t\tGL.push(value.toString());          // Lo que guardamos es el valor pero en cadena de caracteres, porque así es como será leído después.\r\n\t\t\t\t\tlookForGL = false;\r\n\t\t\t\t\tcondition = (lookForDF || lookForBaseHeight || lookForEndHeight || lookForNullValue || lookForStep);\r\n\t\t\t\t\tif (separatedfirstElement[1] === \"FT\"){\r\n\t\t\t\t\t\tGL.push(1);\r\n\t\t\t\t\t\tfeetAreApplied = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tGL.push(0);\r\n\t\t\t\t\t\tmetersAreApplied = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t// Caso en que buscamos la altura base\r\n\t\t\t\tcase \"STRT\":\r\n\t\t\t\t\tvar value = parseFloat(currentLine[1]); // El 'parseFloat' elimina caracteres adicionales al número, como si por ejemplo tenemos \"3175:\", lo deja en 3175.\r\n\r\n\t\t\t\t\tif (currentLine.length > 2){\r\n\t\t\t\t\t\tif (currentLine[3] === \"DEPTH\"){\r\n\t\t\t\t\t\t\tvalue *= -1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tBaseHeight.push(value.toString());  // Lo que guardamos es el valor pero en cadena de caracteres, porque así es como será leído después.\r\n\t\t\t\t\tlookForBaseHeight = false;\r\n\t\t\t\t\tcondition = (lookForDF || lookForGL || lookForEndHeight || lookForNullValue || lookForStep);\r\n\t\t\t\t\tif (separatedfirstElement[1] === \"FT\"){\r\n\t\t\t\t\t\tBaseHeight.push(1);\r\n\t\t\t\t\t\tfeetAreApplied = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tBaseHeight.push(0);\r\n\t\t\t\t\t\tmetersAreApplied = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t// Caso en que buscamos la altura terminal\r\n\t\t\t\tcase \"STOP\":\r\n\t\t\t\t\tvar value = parseFloat(currentLine[1]); // El 'parseFloat' elimina caracteres adicionales al número, como si por ejemplo tenemos \"3175:\", lo deja en 3175.\r\n\t\t\t\t\tif (currentLine.length > 2){\r\n\t\t\t\t\t\tif (currentLine[3] === \"DEPTH\"){\r\n\t\t\t\t\t\t\tvalue *= -1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tEndHeight.push(value.toString());   // Lo que guardamos es el valor pero en cadena de caracteres, porque así es como será leído después.\r\n\t\t\t\t\tlookForEndHeight = false;\r\n\t\t\t\t\tcondition = (lookForDF || lookForGL || lookForBaseHeight || lookForNullValue || lookForStep);\r\n\t\t\t\t\tif (separatedfirstElement[1] === \"FT\"){\r\n\t\t\t\t\t\tEndHeight.push(1);\r\n\t\t\t\t\t\tfeetAreApplied = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tEndHeight.push(0);\r\n\t\t\t\t\t\tmetersAreApplied = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t// Caso en que buscamos el valor que se considera como nulo en la tabla\r\n\t\t\t\tcase \"NULL\":\r\n\t\t\t\t\tnullValue = parseFloat(currentLine[1]); // El 'parseFloat' elimina caracteres adicionales al número, como si por ejemplo tenemos \"3175:\", lo deja en 3175.\r\n\t\t\t\t\tlookForNullValue = false;\r\n\t\t\t\t\tcondition = (lookForDF || lookForGL || lookForBaseHeight || lookForEndHeight || lookForStep);\r\n\t\t\t\t\tbreak;\t\t\r\n\r\n\t\t\t\t// Caso en que buscamos el valor que es el paso de la tabla\r\n\t\t\t\tcase \"STEP\":\r\n\t\t\t\t\tvar value   = parseFloat(currentLine[1]); // El 'parseFloat' elimina caracteres adicionales al número, como si por ejemplo tenemos \"3175:\", lo deja en 3175.\r\n\t\t\t\t\tlookForStep = false;\r\n\t\t\t\t\tcondition   = (lookForDF || lookForGL || lookForBaseHeight || lookForEndHeight || lookForNullValue);\r\n\t\t\t\t\tif (separatedfirstElement[1] === \"FT\"){\r\n\t\t\t\t\t\tgammaRayValues.minDifference = [auxiliarFunctions.feetToMeters(value)[0], value];\r\n\t\t\t\t\t\tScale = [auxiliarFunctions.repairNumber(value,20), 1];\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tgammaRayValues.minDifference = [value, auxiliarFunctions.metersToFeet(value)[0]];\r\n\t\t\t\t\t\tScale = [auxiliarFunctions.repairNumber(value,20), 0];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\t\r\n\r\n\t\t\t\tdefault: \r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Aquí paramos la ejecución de este ciclo porque se encontró la cabecera de la tabla\r\n\t\tif (firstElement === \"~A\") {\r\n\t\t\theaderIndex = i;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\t// Caso en que encontramos una cabecera iniciada por \"~A\"\r\n\tif (headerIndex != null) {\r\n\t\tvar currentLine         = linesWithoutSpaces[headerIndex]; // Número de línea que tiene la cabecera de la tabla de valores\r\n\t\tvar gammaRayPosition    = currentLine.findIndex(element => element === \"GR\"); // Como la tabla tiene varias columnas, hay que ver qué número de columna es la del gamma-ray\r\n\t\t\r\n\t\t// Primero determinamos cuál es la unidad de medición\r\n\t\tif ((feetAreApplied && !metersAreApplied) || (feetAreApplied && metersAreApplied) || (!feetAreApplied && !metersAreApplied)) {\r\n\t\t\t// >>>>>>>>>>>>>>> OJO CON ESTE CASO:Si se aplicaron las dos unidades de medición o si no se aplicó ninguna, entonces no hay manera de saber cuál es la\r\n\t\t\t// estándar de este documento, por lo que tomamos la decisión (arbitraria) de considerar que se están utilizando pies en la tabla de \"gamma-ray\"\r\n\t\t\tvar unit = 1;\r\n\t\t}\r\n\t\telse { // Sólo consideramos que las unidades son metros cuando no se leyó ningún \"FT\", y sí se leyó algún dato numérico\r\n\t\t\tvar unit = 0;\r\n\t\t}\r\n\r\n\t\t// Número de columna de la tabla donde se indican las profundidades\r\n\t\tvar depthPosition = currentLine.findIndex(element => element === \"Depth\");\r\n\r\n\t\t// Esto es sólo para inicializar estas variables\r\n\t\tvar newDepthValueMeters = null; // Valor de profundidad en metros\r\n\t\tvar newDepthValueFeet   = null; // Valor de profundidad en pies\r\n\t\tvar newGRValue          = null; // Valor de gamma-ray\r\n\t\t\r\n\t\t// Separamos por casos dependiendo de si ya fue leído un paso o no, porque si fue leído entonces no debemos preocuparnos por\r\n\t\t// encontrar una diferencia mínima al leer la tabla\r\n\t\tif (gammaRayValues.minDifference != null) {   // Aquí ya hemos encontrado un paso\r\n\t\t\t\r\n\t\t\t// También separamos por casos dependiendo de si lo que estamos leyendo son valores en metros o en pies.\r\n\t\t\t// No ponemos este condicional dentro del for para que no haya que evaluarlo en cada iteración\r\n\r\n\t\t\tif (unit == 0){ // Caso en que los valores de profundidad representan metros\r\n\t\t\t\tfor (i = headerIndex + 1; i < linesWithoutSpaces.length; i++){ \r\n\t\t\t\t\tcurrentLine         = linesWithoutSpaces[i];\r\n\t\t\t\t\tnewDepthValueMeters = parseFloat(currentLine[depthPosition]) * (-1);\r\n\t\t\t\t\tnewDepthValueFeet   = auxiliarFunctions.metersToFeet(newDepthValueMeters)[0];\r\n\t\t\t\t\tnewGRValue          = parseFloat(currentLine[gammaRayPosition]);\r\n\r\n\t\t\t\t\tif (!Number.isNaN(newGRValue)){ // Por si acaso se lee una línea vacía\r\n\r\n\t\t\t\t\t\tgammaRayValues.xValuesMeters.push(newDepthValueMeters);\r\n\t\t\t\t\t\tgammaRayValues.xValuesFeet.push(newDepthValueFeet);\r\n\r\n\t\t\t\t\t\tif (newGRValue != nullValue){\r\n\t\t\t\t\t\t\tgammaRayValues.yValues.push(newGRValue);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tgammaRayValues.yValues.push(null);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse { // Caso en que los valores de profundidad representan pies\r\n\t\t\t\tfor (i = headerIndex + 1; i < linesWithoutSpaces.length; i++){\r\n\t\t\t\t\tcurrentLine         = linesWithoutSpaces[i];\r\n\t\t\t\t\tnewDepthValueFeet   = parseFloat(currentLine[depthPosition]) * (-1);\r\n\t\t\t\t\tnewDepthValueMeters = auxiliarFunctions.feetToMeters(newDepthValueFeet)[0];\r\n\t\t\t\t\tnewGRValue          = parseFloat(currentLine[gammaRayPosition]);\r\n\r\n\t\t\t\t\tif (!Number.isNaN(newGRValue)){ // Por si acaso se lee una línea vacía\r\n\r\n\t\t\t\t\t\tgammaRayValues.xValuesMeters.push(newDepthValueMeters);\r\n\t\t\t\t\t\tgammaRayValues.xValuesFeet.push(newDepthValueFeet);\r\n\r\n\t\t\t\t\t\tif (newGRValue != nullValue){\r\n\t\t\t\t\t\t\tgammaRayValues.yValues.push(newGRValue);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tgammaRayValues.yValues.push(null);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else { // Caso en que el documento no suministró un paso, por lo que tenemos que encontrar la mínima diferencia\r\n\r\n\t\t\tvar minDifference = 10000000; // Esta variable almacenará la mínima diferencia leída\r\n\r\n\t\t\t// Caso en que los valores de profundidad representan metros\r\n\t\t\tif (unit == 0){ \r\n\r\n\t\t\t\t// Esta primera iteración la sacamos del ciclo para que no haya que comprobar en todo momento si la lectura anterior, que se va \r\n\t\t\t\t// a utilizar para obtener la diferencia entre la actual y la anterior, era nula, lo cual ocurre en la primera iteración únicamente.\r\n\t\t\t\tcurrentLine         = linesWithoutSpaces[headerIndex + 1];\r\n\t\t\t\tnewDepthValueMeters = parseFloat(currentLine[depthPosition]) * (-1);\r\n\t\t\t\tnewDepthValueFeet   = auxiliarFunctions.metersToFeet(newDepthValueMeters)[0];\r\n\t\t\t\tnewGRValue          = parseFloat(currentLine[gammaRayPosition]);\r\n\r\n\t\t\t\tif (!Number.isNaN(newGRValue)){ // Por si acaso se lee una línea vacía\r\n\r\n\t\t\t\t\tgammaRayValues.xValuesMeters.push(newDepthValueMeters);\r\n\t\t\t\t\tgammaRayValues.xValuesFeet.push(newDepthValueFeet);\r\n\r\n\t\t\t\t\tif (newGRValue != nullValue){\r\n\t\t\t\t\t\tgammaRayValues.yValues.push(newGRValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tgammaRayValues.yValues.push(null);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar previousLecture = newDepthValueMeters; \r\n\r\n\t\t\t\tfor (i = headerIndex + 2; i < linesWithoutSpaces.length; i++){ \r\n\t\t\t\t\tcurrentLine         = linesWithoutSpaces[i];\r\n\t\t\t\t\tnewDepthValueMeters = parseFloat(currentLine[depthPosition]) * (-1);\r\n\t\t\t\t\tnewDepthValueFeet   = auxiliarFunctions.metersToFeet(newDepthValueMeters)[0];\r\n\t\t\t\t\tnewGRValue          = parseFloat(currentLine[gammaRayPosition]);\r\n\r\n\t\t\t\t\tif (!Number.isNaN(newGRValue)){ // Por si acaso se lee una línea vacía\r\n\r\n\t\t\t\t\t\tgammaRayValues.xValuesMeters.push(newDepthValueMeters);\r\n\t\t\t\t\t\tgammaRayValues.xValuesFeet.push(newDepthValueFeet);\r\n\r\n\t\t\t\t\t\tif (newGRValue != nullValue){\r\n\t\t\t\t\t\t\tgammaRayValues.yValues.push(newGRValue);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tgammaRayValues.yValues.push(null);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tminDifference   = Math.min(minDifference, previousLecture - newDepthValueMeters);\r\n\t\t\t\t\t\tpreviousLecture = newDepthValueMeters;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tgammaRayValues.minDifference = [minDifference, auxiliarFunctions.metersToFeet(minDifference)[0]];\r\n\t\t\t}\r\n\t\t\telse { // Caso en que los valores de profundidad representan pies\r\n\r\n\t\t\t\t// Esta primera iteración la sacamos del ciclo para que no haya que comprobar en todo momento si la lectura anterior, que se va \r\n\t\t\t\t// a utilizar para obtener la diferencia entre la actual y la anterior, era nula, lo cula ocurre en la primera iteración únicamente.\r\n\t\t\t\tcurrentLine         = linesWithoutSpaces[headerIndex + 1];\r\n\t\t\t\tnewDepthValueFeet   = parseFloat(currentLine[depthPosition]) * (-1);\r\n\t\t\t\tnewDepthValueMeters = auxiliarFunctions.feetToMeters(newDepthValueFeet)[0];\r\n\t\t\t\tnewGRValue          = parseFloat(currentLine[gammaRayPosition]);\r\n\r\n\t\t\t\tif (!Number.isNaN(newGRValue)){ // Por si acaso se lee una línea vacía\r\n\r\n\t\t\t\t\tgammaRayValues.xValuesMeters.push(newDepthValueMeters);\r\n\t\t\t\t\tgammaRayValues.xValuesFeet.push(newDepthValueFeet);\r\n\r\n\t\t\t\t\tif (newGRValue != nullValue){\r\n\t\t\t\t\t\tgammaRayValues.yValues.push(newGRValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tgammaRayValues.yValues.push(null);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar previousLecture = newDepthValueFeet; \r\n\r\n\t\t\t\tfor (i = headerIndex + 2; i < linesWithoutSpaces.length; i++){\r\n\t\t\t\t\tcurrentLine         = linesWithoutSpaces[i];\r\n\t\t\t\t\tnewDepthValueFeet   = parseFloat(currentLine[depthPosition]) * (-1);\r\n\t\t\t\t\tnewDepthValueMeters = auxiliarFunctions.feetToMeters(newDepthValueFeet)[0];\r\n\t\t\t\t\tnewGRValue          = parseFloat(currentLine[gammaRayPosition]);\r\n\r\n\t\t\t\t\tif (!Number.isNaN(newGRValue)){ // Por si acaso se lee una línea vacía\r\n\r\n\t\t\t\t\t\tgammaRayValues.xValuesMeters.push(newDepthValueMeters);\r\n\t\t\t\t\t\tgammaRayValues.xValuesFeet.push(newDepthValueFeet);\r\n\r\n\t\t\t\t\t\tif (newGRValue != nullValue){\r\n\t\t\t\t\t\t\tgammaRayValues.yValues.push(newGRValue);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tgammaRayValues.yValues.push(null);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tminDifference   = Math.min(minDifference, previousLecture - newDepthValueFeet);\r\n\t\t\t\t\t\tpreviousLecture = newDepthValueFeet;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tgammaRayValues.minDifference = [auxiliarFunctions.feetToMeters(minDifference)[0], minDifference];\r\n\t\t\t}\r\n\t\t}\r\n\t\tgammaRayValues.numberMeasurements = gammaRayValues.yValues.length;\r\n\t\tgammaRayValues.minYValue = Math.min.apply(Math, gammaRayValues.yValues);\r\n\t\tgammaRayValues.maxYValue = Math.max.apply(Math, gammaRayValues.yValues);\r\n\t}\r\n\treturn {DF, GL, BaseHeight, EndHeight, Scale, gammaRayValues};\r\n}"]},"metadata":{},"sourceType":"module"}