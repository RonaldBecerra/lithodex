{"ast":null,"code":"import * as Regex from \"../constants/regularExpressions\";\nimport shortid from 'shortid';\n\nfunction integerAndExponent(text) {\n  var e_separation = text.split(\"e\");\n  var addedDecimals = e_separation[1] != null ? -1 * e_separation[1] : 0;\n  var dot_separation = e_separation[0].split('.');\n  var noDecimalsNumber = dot_separation[0];\n\n  if (dot_separation[1] != null) {\n    noDecimalsNumber += dot_separation[1];\n    addedDecimals += dot_separation[1].length;\n  }\n\n  return [parseInt(noDecimalsNumber), addedDecimals];\n}\n\nfunction stringNumber(number) {\n  var addedDecimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n  if (addedDecimals == null) {\n    var intAndExp = integerAndExponent(number.toString());\n    var integerNumber = intAndExp[0];\n    addedDecimals = intAndExp[1];\n    var string = integerNumber.toString();\n  } else {\n    var string = number.toString();\n  }\n\n  if (addedDecimals != 0) {\n    var numberZerosToAdd_beginning = addedDecimals - string.length;\n\n    if (numberZerosToAdd_beginning >= 0) {\n      string = \"0\" + \".\" + \"0\".repeat(numberZerosToAdd_beginning) + string;\n    } else if (numberZerosToAdd_beginning < 0) {\n      string = string.slice(0, -numberZerosToAdd_beginning) + \".\" + string.slice(-numberZerosToAdd_beginning);\n    }\n  }\n\n  return string;\n}\n\nfunction numberRoundedToN(number, N) {\n  var string = stringNumber(number);\n\n  if (string.length < N) {\n    var _returnNumber = parseFloat(string);\n\n    if (_returnNumber == 0) {\n      return [0, \"0\"];\n    }\n\n    return [_returnNumber, string];\n  }\n\n  var indexDot = string.indexOf(\".\");\n  var provNumber = null;\n  var trimmedString = string;\n\n  if (indexDot >= N - 1) {\n    provNumber = parseFloat(string).toFixed(0);\n    trimmedString = stringNumber(provNumber).substring(0, N);\n  } else if (0 < indexDot) {\n    provNumber = parseFloat(string).toFixed(N - indexDot - 1);\n    trimmedString = stringNumber(provNumber);\n    var numberZerosToEliminate = 0;\n\n    for (i = N - 1; i > indexDot; i--) {\n      if (trimmedString[i] == \"0\") {\n        numberZerosToEliminate += 1;\n      } else {\n        break;\n      }\n    }\n\n    trimmedString = trimmedString.substring(0, N - numberZerosToEliminate);\n    var len_MinusOne = trimmedString.length - 1;\n\n    if (trimmedString[len_MinusOne] == \".\") {\n      trimmedString = trimmedString.substring(0, len_MinusOne);\n    }\n  }\n\n  var returnNumber = parseFloat(trimmedString);\n\n  if (returnNumber == 0) {\n    return [0, \"0\"];\n  }\n\n  return [returnNumber, trimmedString];\n}\n\nfunction eliminatedNinesNumber(integerNumber, exponent, N) {\n  if (N <= 0) {\n    return [null, null];\n  }\n\n  var TOLERANCE = 0.01;\n  var originalNumber = parseFloat(stringNumber(integerNumber, -exponent));\n  var string = integerNumber.toString();\n  var len = string.length;\n  var numberOfNinesInARow = 0;\n  var condition = true;\n  var returnNumber = originalNumber;\n  var roundedNumber = null;\n\n  for (var i = len - 1; i >= 0; i--) {\n    if (string[i] == '9') {\n      numberOfNinesInARow += 1;\n    } else {\n      if (numberOfNinesInARow > 4) {\n        var digit = parseInt(string[i]) + 1;\n        var string2 = \"\";\n\n        for (var k = 0; k < i; k++) {\n          string2 += string[k];\n        }\n\n        string2 += digit.toString();\n\n        for (k = i + 1; k < len; k++) {\n          string2 += \"0\";\n        }\n\n        roundedNumber = parseFloat(stringNumber(parseInt(string2), -exponent));\n\n        if (roundedNumber - originalNumber < TOLERANCE) {\n          returnNumber = roundedNumber;\n        } else {\n          condition = false;\n          break;\n        }\n      }\n\n      numberOfNinesInARow = 0;\n    }\n  }\n\n  if (condition && numberOfNinesInARow > 4) {\n    string2 = \"1\";\n\n    for (i = 0; i < len; i++) {\n      string2 += \"0\";\n    }\n\n    var _roundedNumber = parseFloat(stringNumber(parseInt(string2), -exponent));\n\n    if (_roundedNumber - originalNumber < TOLERANCE) {\n      return numberRoundedToN(_roundedNumber, N);\n    }\n  }\n\n  return numberRoundedToN(returnNumber, N);\n}\n\nexport function metersToFeet(numberText) {\n  if (numberText == null) {\n    return [null, null];\n  }\n\n  if (typeof numberText == 'number') {\n    numberText = numberText.toString();\n  }\n\n  var result = integerAndExponent(numberText);\n  return eliminatedNinesNumber(result[0] * 32808, -4 - result[1], 10);\n}\nexport function feetToMeters(numberText) {\n  if (numberText == null) {\n    return [null, null];\n  }\n\n  if (typeof numberText == 'number') {\n    numberText = numberText.toString();\n  }\n\n  var result = integerAndExponent(numberText);\n  return eliminatedNinesNumber(result[0] * 30480370, -8 - result[1], 9);\n}\nexport function repairNumber(number, N) {\n  if (number == null || N < 0) {\n    return [null, null];\n  }\n\n  if (typeof number == 'string') {\n    number = parseFloat(number);\n  }\n\n  if (number == 0) {\n    return [0, \"0\"];\n  }\n\n  var string = number.toString();\n  var result = integerAndExponent(string);\n\n  if (result[1] != 0) {\n    return eliminatedNinesNumber(result[0], -result[1], N);\n  }\n\n  return [number, string];\n}\nexport function isValidPositiveDecimalNumber(text) {\n  if (Regex.REGULAR_EXPRESSION_1.test(text)) {\n    return true;\n  }\n\n  return false;\n}\nexport function isValidDecimalNumber(text) {\n  if (Regex.REGULAR_EXPRESSION_2.test(text) || Regex.REGULAR_EXPRESSION_3.test(text)) {\n    return true;\n  }\n\n  return false;\n}\nexport function onlyLettersAndNumbers(text) {\n  if (Regex.REGULAR_EXPRESSION_4.test(text)) {\n    return true;\n  }\n\n  return false;\n}\nexport function isValidEmail(text) {\n  if (Regex.REGULAR_EXPRESSION_6.test(text)) {\n    return true;\n  }\n\n  return false;\n}\nexport function stringIncludesSubstring_NoStrict(string, substring) {\n  if (string.toLowerCase().normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\").includes(substring.toLowerCase().normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\"))) {\n    return true;\n  } else {\n    return false;\n  }\n}\nexport function generateObject_id() {\n  return \"lithodex_object\" + \"_\" + shortid.generate() + \"_\" + new Date().getTime();\n}\nexport function generateUser_id() {\n  return \"lithodex_user_\" + shortid.generate() + \"_\" + new Date().getTime();\n}\nexport function generate_key() {\n  return shortid.generate() + \"_\" + new Date().getTime();\n}\nexport function max(number1, number2) {\n  if (typeof number1 == 'string') {\n    number1 = parseFloat(number1);\n  }\n\n  if (typeof number2 == 'string') {\n    number2 = parseFloat(number2);\n  }\n\n  if (number1 == null) {\n    return number2;\n  }\n\n  if (number2 == null) {\n    return number1;\n  }\n\n  return Math.max(number1, number2);\n}\nexport function min(number1, number2) {\n  if (typeof number1 == 'string') {\n    number1 = parseFloat(number1);\n  }\n\n  if (typeof number2 == 'string') {\n    number2 = parseFloat(number2);\n  }\n\n  if (number1 == null) {\n    return number2;\n  }\n\n  if (number2 == null) {\n    return number1;\n  }\n\n  return Math.min(number1, number2);\n}\nexport function test() {\n  var boolean = true;\n  var string = null;\n  string = \"8382.83999997489378299999\";\n  boolean = boolean && repairNumber(string, 20)[1] === \"8382.84\";\n  string = \"6.99999199999\";\n  boolean = boolean && repairNumber(string, 20)[1] === \"7\";\n  string = \"99999.9999\";\n  boolean = boolean && repairNumber(string, 20)[1] === \"100000\";\n  string = \"9999.938382\";\n  boolean = boolean && repairNumber(string, 20)[1] === \"9999.938382\";\n  string = \"3.2808\";\n  boolean = boolean && feetToMeters(string)[1] === \"1\";\n  string = \"0.0000001\";\n  boolean = boolean && metersToFeet(string)[1] === \"0.00000033\";\n  string = \"0.000001\";\n  boolean = boolean && metersToFeet(string)[1] === \"0.00000328\";\n  string = \"-\";\n  boolean = boolean && isValidDecimalNumber(string) && !isValidPositiveDecimalNumber(string);\n  string = \"0\";\n  boolean = boolean && isValidPositiveDecimalNumber(string);\n  string = \"fhK1939292ooe\";\n  boolean = boolean && onlyLettersAndNumbers(string) && !isValidDecimalNumber(string) && !isValidPositiveDecimalNumber(string);\n  string = \"íüùÍÜÙ\";\n  boolean = boolean && onlyLettersAndNumbers(string);\n  string = \"Mi perro ladró\";\n  boolean = boolean && stringIncludesSubstring_NoStrict(string, \"mÍ\") && stringIncludesSubstring_NoStrict(string, \"erro\") && stringIncludesSubstring_NoStrict(string, \" lad\") && !stringIncludesSubstring_NoStrict(string, \"ferro\") && stringIncludesSubstring_NoStrict(string, \" ladro\");\n  string = \"pingüino àlto\";\n  boolean = boolean && stringIncludesSubstring_NoStrict(string, \"pinguino alto\");\n  boolean = boolean && max(null, -23) == -23 && max(null, 5) == 5 && max(3, -23) == 3;\n  boolean = boolean && min(null, -23) == -23 && min(null, 5) == 5 && min(3, -23) == -23;\n  return boolean;\n}","map":{"version":3,"sources":["C:/Users/Ronald/Documents/Universidad/Miniproyecto/Proyecto final - geología/Versiones de la aplicación/lithodex/src/genericFunctions/otherFunctions.js"],"names":["Regex","shortid","integerAndExponent","text","e_separation","split","addedDecimals","dot_separation","noDecimalsNumber","length","parseInt","stringNumber","number","intAndExp","toString","integerNumber","string","numberZerosToAdd_beginning","repeat","slice","numberRoundedToN","N","returnNumber","parseFloat","indexDot","indexOf","provNumber","trimmedString","toFixed","substring","numberZerosToEliminate","i","len_MinusOne","eliminatedNinesNumber","exponent","TOLERANCE","originalNumber","len","numberOfNinesInARow","condition","roundedNumber","digit","string2","k","metersToFeet","numberText","result","feetToMeters","repairNumber","isValidPositiveDecimalNumber","REGULAR_EXPRESSION_1","test","isValidDecimalNumber","REGULAR_EXPRESSION_2","REGULAR_EXPRESSION_3","onlyLettersAndNumbers","REGULAR_EXPRESSION_4","isValidEmail","REGULAR_EXPRESSION_6","stringIncludesSubstring_NoStrict","toLowerCase","normalize","replace","includes","generateObject_id","generate","Date","getTime","generateUser_id","generate_key","max","number1","number2","Math","min","boolean"],"mappings":"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","sourcesContent":["import * as Regex from '../constants/regularExpressions'\r\nimport shortid from 'shortid'\r\n\r\n/* Función que recibe un número expresado en cadena de caracteres. \r\n   Devuelve un arreglo con dos valores: \r\n   (1) el mismo número pero habiéndole quitado el punto decimal, y \r\n   (2) el número de veces que habría que correr el punto decimal a la izquierda, (empezando desde el extremo derecho), para obtener de nuevo el mismo número \r\n*/\r\nfunction integerAndExponent(text){\r\n\t// Primero procedemos a separar el número de acuerdo a la letra \"e\", de \"exponente\" ya que algunos números en \r\n\t// punto flotante vendrán expresados con la potencia precedida por dicha letra\r\n\tconst e_separation = text.split(\"e\");\r\n\r\n\t// Cantidad de veces que la letra \"e\" indica que hay que correr el punto decimal a la izquierda.\r\n\t// (Es necesario invertir el signo)\r\n\tvar addedDecimals = (e_separation[1] != null) ? (-1 * e_separation[1]) : 0;\r\n\r\n\t// Ahora separamos de nuevo el número pero de acuerdo al punto decimal\r\n\tconst dot_separation = e_separation[0].split('.');\r\n\r\n\t// Éste es el número equivalente al que estamos trabajando si no tuviese los decimales\r\n\tvar noDecimalsNumber = dot_separation[0];\r\n\r\n\tif (dot_separation[1] != null){\r\n\t\tnoDecimalsNumber += dot_separation[1];\r\n\t\taddedDecimals += dot_separation[1].length;\r\n\t}\r\n\treturn [parseInt(noDecimalsNumber), addedDecimals];\r\n}\r\n\r\n/* Función que recibe un número, que puede estar expresado en punto flotante, y lo devuelve expresado como\r\n   cadena de caracteres sin hacer uso de las potencias. Esto es importante cuando tenemos algo como \"3.09482e-9\", \r\n   y queremos obtener su notación sin el \"e-9\", es decir, 0.00000000309482.\r\n */\r\nfunction stringNumber(number, addedDecimals=null){\r\n\t// En este caso se supone que recibimos un número expresado en punto flotante, por lo que tenemos que ver\r\n\t// cuántos decimales hay. Recuérdese que puede haber aparecido una potencia con la letra \"e\".\r\n\tif (addedDecimals == null){\r\n\t\tvar intAndExp     = integerAndExponent(number.toString());\r\n\t\tvar integerNumber = intAndExp[0];\r\n\t\taddedDecimals     = intAndExp[1];\r\n\r\n\t\tvar string = integerNumber.toString();\r\n\t} else { // En este caso se supone que \"number\" es un entero, y los decimales ya nos los indica la entrada\r\n\t\tvar string = number.toString();\r\n\t}\r\n\r\n\tif (addedDecimals != 0){\r\n\t\t// Determinamos la cantidad de ceros a añadir después del punto decimal si es que la mantisa está después del punto decimal.\r\n\t\t// Por ejemplo, en 0.00003, la cantidad de ceros sería 4.\r\n\t\tconst numberZerosToAdd_beginning = addedDecimals - string.length;\r\n\r\n\t\tif (numberZerosToAdd_beginning >= 0){\r\n\t\t\tstring = \"0\" + \".\" + \"0\".repeat(numberZerosToAdd_beginning) + string;\r\n\t\t}\r\n\t\telse if (numberZerosToAdd_beginning < 0){\r\n\t\t\tstring = string.slice(0, -numberZerosToAdd_beginning) + \".\" + string.slice(-numberZerosToAdd_beginning);\r\n\t\t}\r\n\t}\r\n\treturn string;\r\n}\r\n\r\n/* Función que recibe un número y lo acorta de modo que su cadena correspondiente sólo tenga hasta \r\n   N caracteres (incluyendo el punto decimal). Entonces le quita los ceros que queden más a la derecha\r\n   del número, en caso de que éste tenga parte decimal. El resultado es redondeado, no truncado.\r\n\r\n   Lo que devuelve es en realidad un arreglo de dos valores: el número en punto flotante, y el número\r\n   como cadena de caracteres\r\n */\r\nfunction numberRoundedToN(number, N){\r\n\tvar string = stringNumber(number);\r\n\r\n\t// Si el número tiene N símbolos o menos, entonces lo podemos retornar directamente sin aplicarle ningún proceso\r\n\t// ya que no quedarán 0's a la derecha de las cifras significativas después del punto decimal\r\n\tif (string.length < N){\r\n\t\tconst returnNumber = parseFloat(string);\r\n\t\tif (returnNumber == 0){\r\n\t\t\treturn [0, \"0\"];\r\n\t\t}\r\n\t\treturn [returnNumber, string];\r\n\t}\r\n\t// Caso contrario en que el número tiene más de N símbolos\r\n\tvar indexDot      = string.indexOf(\".\"); // Índice en el que aparece el punto decimal\r\n\tvar provNumber    = null;\r\n\tvar trimmedString = string; \r\n\r\n\tif (indexDot >= N-1){\r\n\t\tprovNumber = parseFloat(string).toFixed(0);\r\n\t\ttrimmedString = stringNumber(provNumber).substring(0,N);\r\n\t}\r\n\telse if (0 < indexDot){\r\n\t\tprovNumber = parseFloat(string).toFixed(N-indexDot-1);\r\n\t\ttrimmedString = stringNumber(provNumber);\r\n\r\n\t\t// Aquí procedemos a eliminar los 0's que sobraron\r\n\t\tvar numberZerosToEliminate = 0;\r\n\r\n\t\tfor (i = N-1; i > indexDot; i--){\r\n\t\t\tif (trimmedString[i] == \"0\"){\r\n\t\t\t\tnumberZerosToEliminate += 1;\r\n\t\t\t} else {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\ttrimmedString = trimmedString.substring(0, N-numberZerosToEliminate);\r\n\t\tconst len_MinusOne = trimmedString.length - 1;\r\n\r\n\t\tif (trimmedString[len_MinusOne] == \".\"){\r\n\t\t\ttrimmedString = trimmedString.substring(0,len_MinusOne);\r\n\t\t}\t\r\n\t} \r\n\r\n\tconst returnNumber = parseFloat(trimmedString);\r\n\tif (returnNumber == 0){\r\n\t\treturn [0, \"0\"];\r\n\t}\r\n\treturn [returnNumber, trimmedString];\r\n}\r\n\r\n/* Función que recibe un número entero, y también recibe un exponente para luego transformar ese \r\n   entero en decimal. Si reconoce un patrón de cinco 9's seguidos, aumenta en uno la última cifra \r\n   que no era 9 a la izquierda de la cadena, y transforma el resto en 0's. Esto permite convertir\r\n   números como 0,9999... en 1. Recibe además un número N que indica a cuántos símbolos debe luego\r\n   truncarse el número, para lo cual se usa la función auxiliar numberCutToN.\r\n\r\n   Lo que devuelve es en realidad un arreglo de dos valores: el número en punto flotante, y el número\r\n   como cadena de caracteres.\r\n */\r\nfunction eliminatedNinesNumber(integerNumber,exponent, N){\r\n\tif (N <= 0){\r\n\t\treturn [null, null];\r\n\t}\r\n\r\n\t/* Sólo eliminamos la cadena de cinco 9's seguidos si la diferencia entre el número convertido\r\n       y el número original es menor que 0.01. Esta toletancia fue elegida arbitrariamente*/\r\n\tconst TOLERANCE = 0.01; \r\n\r\n\t//const originalNumber = integerNumber * Math.pow(10,exponent);\r\n\tconst originalNumber = parseFloat(stringNumber(integerNumber, -exponent));\r\n\r\n\tconst string = integerNumber.toString();\r\n\tconst len    = string.length; \r\n\r\n\tvar numberOfNinesInARow = 0; // Cantidad de 9's seguidos que hemos conseguido\r\n\tvar condition = true;  // \r\n\tvar returnNumber  = originalNumber;\r\n\tvar roundedNumber = null;\r\n\r\n\tfor (var i = len-1; i >= 0; i--){\r\n\t\tif (string[i] == '9'){\r\n\t\t\tnumberOfNinesInARow += 1;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (numberOfNinesInARow > 4){\r\n\t\t\t\t// En este caso construimos el nuevo número\r\n\t\t\t\tvar digit = parseInt(string[i]) + 1;\r\n\t\t\t\tvar string2 = \"\";\r\n\t\t\t\tfor (var k = 0; k < i; k ++){\r\n\t\t\t\t\tstring2 += string[k];\r\n\t\t\t\t}\r\n\t\t\t\tstring2 += digit.toString();\r\n\t\t\t\tfor (k = i+1; k < len; k ++){\r\n\t\t\t\t\tstring2 += \"0\";\r\n\t\t\t\t}\r\n\t\t\t\troundedNumber = parseFloat(stringNumber(parseInt(string2), -exponent));\r\n\t\t\t\tif (roundedNumber - originalNumber < TOLERANCE){\r\n\t\t\t\t\treturnNumber = roundedNumber;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tcondition = false;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tnumberOfNinesInARow = 0;\r\n\t\t}\r\n\t}\r\n\tif (condition && (numberOfNinesInARow > 4)){\r\n\t\t// En este caso construimos el nuevo número\r\n\t\tstring2 = \"1\"\r\n\t\tfor (i = 0; i < len; i++){\r\n\t\t\tstring2 += \"0\";\r\n\t\t}\r\n\t\tconst roundedNumber = parseFloat(stringNumber(parseInt(string2), -exponent));\r\n\t\tif (roundedNumber - originalNumber < TOLERANCE){\r\n\t\t\treturn numberRoundedToN(roundedNumber, N);\r\n\t\t}\r\n\t}\r\n\treturn numberRoundedToN(returnNumber, N);\t\r\n}\r\n\r\n/* Función que convierte un número expresado en metros a su valor correspondiente en pies.\r\n\r\n   Devuelve el número con hasta 10 símbolos, porque recuérdese que en los cuadros de texto \r\n   de los formularios en donde se ingresan números con unidades de medición establecimos que \r\n   se muestran hasta 10 caracteres si estamos trabajando con pies.\r\n\r\n   Lo que devuelve es en realidad un arreglo de dos valores: el número en punto flotante, y el número\r\n   como cadena de caracteres.\r\n */\r\nexport function metersToFeet(numberText){\r\n\tif (numberText == null){\r\n\t\treturn [null, null];\r\n\t}\r\n\r\n\tif (typeof(numberText) == 'number'){\r\n\t\tnumberText = numberText.toString();\r\n\t}\r\n\tconst result = integerAndExponent(numberText);\r\n\treturn eliminatedNinesNumber(result[0] * 32808, -4-result[1], 10);\r\n}\r\n\r\n/* Función que convierte un número expresado en pies a su valor correspondiente en metros.\r\n\r\n   Devuelve el número con hasta 9 símbolos, porque recuérdese que en los cuadros de texto \r\n   de los formularios en donde se ingresan números con unidades de medición establecimos que \r\n   se muestran hasta 9 caracteres si estamos trabajando con metros. \r\n\r\n   Lo que devuelve es en realidad un arreglo de dos valores: el número en punto flotante, y el número\r\n   como cadena de caracteres.\r\n */\r\nexport function feetToMeters(numberText){\r\n\tif (numberText == null){\r\n\t\treturn [null, null];\r\n\t}\r\n\r\n\tif (typeof(numberText) == 'number'){\r\n\t\tnumberText = numberText.toString();\r\n\t}\r\n\tconst result = integerAndExponent(numberText);\r\n\treturn eliminatedNinesNumber(result[0] * 30480370, -8-result[1], 9);\r\n}\r\n\r\n/* Función que recibe un número (no cadena de caracteres), y lo deja sólo con N símbolos, eliminando\r\n   cualquier secuencia de cinco 9's seguidos. Además si quedan ceros al extremo derecho habiendo un punto decimal,\r\n   se eliminan. También recibe un número N, que indica a cuántos caracteres debe truncarse el número.\r\n\r\n   Lo que devuelve es en realidad un arreglo de dos valores: el número en punto flotante, y el número\r\n   como cadena de caracteres.\r\n */\r\nexport function repairNumber(number, N){\r\n\tif ((number == null) || (N < 0)){\r\n\t\treturn [null,null];\r\n\t}\r\n\tif (typeof(number) == 'string'){\r\n\t\tnumber = parseFloat(number);\r\n\t}\r\n\tif (number == 0){\r\n\t\treturn [0, \"0\"];\r\n\t}\r\n\tconst string = number.toString();\r\n\tconst result = integerAndExponent(string);\r\n\tif (result[1] != 0){\r\n\t\treturn eliminatedNinesNumber(result[0], -result[1], N);\r\n\t}\r\n\treturn [number,string];\r\n}\r\n\r\n// Función para validar una cadena de caracteres como un número decimal (sólo parte entera también se valida), pero no admite números negativos (admite el cero).\r\nexport function isValidPositiveDecimalNumber(text){\r\n\tif (Regex.REGULAR_EXPRESSION_1.test(text)){\r\n\t\treturn true\r\n\t}\r\n\treturn false;\r\n}\r\n\r\n// Función para validar una cadena de caracteres como un número decimal (sólo parte entera también se valida), y también admitiendo números negativos\r\nexport function isValidDecimalNumber(text){\r\n\tif (Regex.REGULAR_EXPRESSION_2.test(text) || Regex.REGULAR_EXPRESSION_3.test(text)){\r\n\t\treturn true\r\n\t}\r\n\treturn false;\r\n}\r\n\r\n// Función para validar una cadena de caracteres sólo cuando posee letras y números; ningún otro carácter adicional, aunque sí admite espacios\r\nexport function onlyLettersAndNumbers(text){\r\n\tif (Regex.REGULAR_EXPRESSION_4.test(text)){\r\n\t\treturn true\r\n\t}\r\n\treturn false;\r\n}\r\n\r\n// Función para determinar si una expresión regular corresponde a un correo electrónico\r\nexport function isValidEmail(text){\r\n\tif (Regex.REGULAR_EXPRESSION_6.test(text)){\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n\r\n/* Función para determinar si una cadena de caracteres llamada \"string\" incluye a otra subcadena llamada \"substring\",\r\n   haciendo caso omiso de las mayúsculas y minúsculas, y de los acentos */\r\nexport function stringIncludesSubstring_NoStrict(string,substring){\r\n\tif (string.toLowerCase().normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\").includes(substring.toLowerCase().normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\"))){\r\n\t\treturn true;\r\n\t}\r\n\telse {\r\n\t\treturn false;\r\n\t}\r\n} \r\n\r\n// Se utiliza para crear los identificadores de los objetos de estudio: núcleos y afloramientos\r\nexport function generateObject_id(){\r\n\treturn \"lithodex_object\" + \"_\" + shortid.generate() + \"_\" + new Date().getTime();\r\n}\r\n\r\n// Se utiliza para generar los identificadores de los usuarios del sistema.\r\nexport function generateUser_id(){\r\n\treturn \"lithodex_user_\" + shortid.generate() + \"_\" + new Date().getTime();\r\n}\r\n\r\n// Generador de clave en el que se mezcla el tiempo actual con un id generado automáticamnte por la función \"shortid\".\r\n// Se utiliza para generar los identificadores de los estratos de un objeto de estudio, y de las imágenes en general.\r\nexport function generate_key(){\r\n\treturn shortid.generate() + \"_\" + new Date().getTime();\r\n}\r\n\r\n// Obtención del máximo elemento entre dos valores numéricos. Se diferencia de la función Math.max en que ignora valores nulos\r\n// en lugar de considerarlos como cero\r\nexport function max(number1,number2){\r\n\tif (typeof(number1) == 'string'){\r\n\t\tnumber1 = parseFloat(number1);\r\n\t}\r\n\tif (typeof(number2) == 'string'){\r\n\t\tnumber2 = parseFloat(number2);\r\n\t}\r\n\r\n\tif (number1 == null){\r\n\t\treturn number2;\r\n\t}\r\n\tif (number2 == null){\r\n\t\treturn number1;\r\n\t}\r\n\treturn Math.max(number1, number2);\r\n}\r\n\r\n// Obtención del mínimo elemento entre dos valores numéricos. Se diferencia de la función Math.min en que ignora valores nulos\r\n// en lugar de considerarlos como cero\r\nexport function min(number1,number2){\r\n\tif (typeof(number1) == 'string'){\r\n\t\tnumber1 = parseFloat(number1);\r\n\t}\r\n\tif (typeof(number2) == 'string'){\r\n\t\tnumber2 = parseFloat(number2);\r\n\t}\r\n\r\n\tif (number1 == null){\r\n\t\treturn number2;\r\n\t}\r\n\tif (number2 == null){\r\n\t\treturn number1;\r\n\t}\r\n\treturn Math.min(number1, number2);\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n////////////////////////////////////////////////////////   P  R  U  E  B  A  S   /////////////////////////////////////////////////////////////////\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\nexport function test(){\r\n\tvar boolean = true;\r\n\tvar string  = null;\r\n\r\n\t// En este número deben haberse eliminado los 9's\r\n\tstring  = \"8382.83999997489378299999\";\r\n\tboolean = boolean && (repairNumber(string, 20)[1] === \"8382.84\");\r\n\r\n\t// En este número deben haberse eliminado los 9's\r\n\tstring  = \"6.99999199999\";\r\n\tboolean = boolean && (repairNumber(string, 20)[1] === \"7\");\r\n\r\n\t// En este número deben haberse eliminado los 9's\r\n\tstring  = \"99999.9999\";\r\n\tboolean = boolean && (repairNumber(string, 20)[1] === \"100000\");\r\n\r\n\t// En este número no se eliminan los 9's\r\n\tstring  = \"9999.938382\";\r\n\tboolean = boolean && (repairNumber(string, 20)[1] === \"9999.938382\");\r\n\r\n\t// Conversión esperada de pies a metros\r\n\tstring  = \"3.2808\";\r\n\tboolean = boolean && (feetToMeters(string)[1] === \"1\");\r\n\r\n\t// Conversión esperada de metros a pies. Esto realmente debería arrojar como resultado 0.00000032808, pero como cortamos a diez símbolos y redondeamos,\r\n\t// entonces el 2 debe convertirse en un 3.\r\n\tstring  = \"0.0000001\";\r\n\tboolean = boolean && (metersToFeet(string)[1] === \"0.00000033\");\r\n\r\n\t// Conversión esperada de metros a pies. Esto realmente debería arrojar como resultado 0.0000032808, pero como cortamos a diez símbolos y redondeamos,\r\n\t// entonces el 0 que está entre los dos 8's debe convertirse en un 1.\r\n\tstring  = \"0.000001\";\r\n\tboolean = boolean && (metersToFeet(string)[1] === \"0.00000328\");\r\n\r\n\t// El signo menos se considera como un decimal válido, puesto que el usario sigue sin haber escrito el número completo, pero no es un positivo válido\r\n\tstring  = \"-\"\r\n\tboolean = boolean && isValidDecimalNumber(string) && (!isValidPositiveDecimalNumber(string));\r\n\r\n\t// El cero se incluye entre los validados como positivos\r\n\tstring  = \"0\"\r\n\tboolean = boolean && isValidPositiveDecimalNumber(string);\r\n\r\n\t// Esta cadena de caracteres sólo tiene letras y números. Pero no puede ser considerada un número decimal\r\n\tstring  = \"fhK1939292ooe\"\r\n\tboolean = boolean && onlyLettersAndNumbers(string) && (!isValidDecimalNumber(string)) && (!isValidPositiveDecimalNumber(string));\r\n\r\n\t// También se reconocen como letras aquéllas que tienen acentos de distintos tipos\r\n\tstring  = \"íüùÍÜÙ\"\r\n\tboolean = boolean && onlyLettersAndNumbers(string);\r\n\r\n\t// Reconocer subcadenas no estrictas válidas, es decir, que no importa si se agregaron/quitaron acentos, o si no corresponden las mayúsculas con las minúsculas\r\n\tstring  = \"Mi perro ladró\"\r\n\tboolean = boolean && stringIncludesSubstring_NoStrict(string, \"mÍ\") && stringIncludesSubstring_NoStrict(string, \"erro\") && stringIncludesSubstring_NoStrict(string, \" lad\") \r\n\t          && (!stringIncludesSubstring_NoStrict(string, \"ferro\")) && stringIncludesSubstring_NoStrict(string, \" ladro\");\r\n\r\n\t// Reconocer subcadenas no estrictas válidas, en este caso incluyendo otros tipos de acentos\r\n\tstring  = \"pingüino àlto\"\r\n\tboolean = boolean && stringIncludesSubstring_NoStrict(string, \"pinguino alto\");\r\n\r\n\t// Obtención del máximo elemento entre dos valores\r\n\tboolean = boolean && (max(null,-23) == -23) && (max(null,5) == 5) && (max(3,-23) == 3);\r\n\r\n\t// Obtención del mínimo elemento entre dos valores\r\n\tboolean = boolean && (min(null,-23) == -23) && (min(null,5) == 5) && (min(3,-23) == -23);\r\n\r\n\treturn boolean;\r\n}"]},"metadata":{},"sourceType":"module"}